{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export interface SSOClientOptions {\n  /** Base URL of the authorization server (e.g. https://auth.inferencelabs.com) */\n  authBaseUrl: string\n  /** Callback URL on your app that receives the authorization code. Defaults to `${origin}/auth/callback` */\n  redirectUri?: string\n  /** Enable PKCE (S256). Defaults to true. */\n  usePKCE?: boolean\n}\n\nexport interface SSOUser {\n  id: string\n  username: string\n  email: string\n}\n\nexport interface TokenExchangeResult {\n  success: boolean\n  jwt: string\n  user: SSOUser\n}\n\nconst SSO_STATE_KEY = 'ias_sso_state'\nconst PKCE_VERIFIER_KEY = 'ias_sso_pkce_verifier'\n\nasync function generatePKCEChallenge(verifier: string): Promise<string> {\n  const digest = await crypto.subtle.digest(\n    'SHA-256',\n    new TextEncoder().encode(verifier)\n  )\n  return btoa(String.fromCharCode(...new Uint8Array(digest)))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '')\n}\n\nfunction generateRandomString(): string {\n  const bytes = new Uint8Array(32)\n  crypto.getRandomValues(bytes)\n  return Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('')\n}\n\nexport class SSOClient {\n  private authBaseUrl: string\n  private redirectUri: string\n  private usePKCE: boolean\n\n  constructor(options: SSOClientOptions) {\n    this.authBaseUrl = options.authBaseUrl.replace(/\\/$/, '')\n    this.redirectUri = options.redirectUri ?? `${window.location.origin}/auth/callback`\n    this.usePKCE = options.usePKCE ?? true\n  }\n\n  /**\n   * Initiates the SSO login flow. Redirects the user to the auth frontend.\n   */\n  async login(): Promise<void> {\n    const state = generateRandomString()\n    sessionStorage.setItem(SSO_STATE_KEY, state)\n\n    const params = new URLSearchParams({\n      redirect_uri: this.redirectUri,\n      state,\n    })\n\n    if (this.usePKCE) {\n      const verifier = generateRandomString()\n      sessionStorage.setItem(PKCE_VERIFIER_KEY, verifier)\n      const challenge = await generatePKCEChallenge(verifier)\n      params.set('code_challenge', challenge)\n      params.set('code_challenge_method', 'S256')\n    }\n\n    window.location.href = `${this.authBaseUrl}/auth/sso/authorize?${params}`\n  }\n\n  /**\n   * Handles the callback after the user authenticates.\n   * Call this on your redirect_uri page. Validates state, exchanges\n   * the authorization code for a JWT, and cleans up session storage.\n   */\n  async handleCallback(searchParams?: URLSearchParams): Promise<TokenExchangeResult> {\n    const params = searchParams ?? new URLSearchParams(window.location.search)\n    const code = params.get('code')\n    const returnedState = params.get('state')\n    const savedState = sessionStorage.getItem(SSO_STATE_KEY)\n\n    if (!code) {\n      throw new Error('Missing authorization code in callback URL')\n    }\n\n    if (!returnedState || returnedState !== savedState) {\n      throw new Error('State mismatch — possible CSRF attack')\n    }\n\n    const body: Record<string, string> = { code }\n\n    if (this.usePKCE) {\n      const verifier = sessionStorage.getItem(PKCE_VERIFIER_KEY)\n      if (!verifier) {\n        throw new Error('Missing PKCE verifier — login flow may have been interrupted')\n      }\n      body.code_verifier = verifier\n    }\n\n    const res = await fetch(`${this.authBaseUrl}/auth/sso/token/exchange`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body),\n    })\n\n    if (!res.ok) {\n      const err = await res.json().catch(() => ({ error: 'Token exchange failed' }))\n      throw new Error((err as { error?: string }).error ?? `HTTP ${res.status}`)\n    }\n\n    sessionStorage.removeItem(SSO_STATE_KEY)\n    sessionStorage.removeItem(PKCE_VERIFIER_KEY)\n\n    return res.json()\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA,IAAM,gBAAgB;AACtB,IAAM,oBAAoB;AAE1B,eAAe,sBAAsB,UAAmC;AACtE,QAAM,SAAS,MAAM,OAAO,OAAO;AAAA,IACjC;AAAA,IACA,IAAI,YAAY,EAAE,OAAO,QAAQ;AAAA,EACnC;AACA,SAAO,KAAK,OAAO,aAAa,GAAG,IAAI,WAAW,MAAM,CAAC,CAAC,EACvD,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE;AACtB;AAEA,SAAS,uBAA+B;AACtC,QAAM,QAAQ,IAAI,WAAW,EAAE;AAC/B,SAAO,gBAAgB,KAAK;AAC5B,SAAO,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAC1E;AAEO,IAAM,YAAN,MAAgB;AAAA,EAKrB,YAAY,SAA2B;AACrC,SAAK,cAAc,QAAQ,YAAY,QAAQ,OAAO,EAAE;AACxD,SAAK,cAAc,QAAQ,eAAe,GAAG,OAAO,SAAS,MAAM;AACnE,SAAK,UAAU,QAAQ,WAAW;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAuB;AAC3B,UAAM,QAAQ,qBAAqB;AACnC,mBAAe,QAAQ,eAAe,KAAK;AAE3C,UAAM,SAAS,IAAI,gBAAgB;AAAA,MACjC,cAAc,KAAK;AAAA,MACnB;AAAA,IACF,CAAC;AAED,QAAI,KAAK,SAAS;AAChB,YAAM,WAAW,qBAAqB;AACtC,qBAAe,QAAQ,mBAAmB,QAAQ;AAClD,YAAM,YAAY,MAAM,sBAAsB,QAAQ;AACtD,aAAO,IAAI,kBAAkB,SAAS;AACtC,aAAO,IAAI,yBAAyB,MAAM;AAAA,IAC5C;AAEA,WAAO,SAAS,OAAO,GAAG,KAAK,WAAW,uBAAuB,MAAM;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,eAAe,cAA8D;AACjF,UAAM,SAAS,gBAAgB,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACzE,UAAM,OAAO,OAAO,IAAI,MAAM;AAC9B,UAAM,gBAAgB,OAAO,IAAI,OAAO;AACxC,UAAM,aAAa,eAAe,QAAQ,aAAa;AAEvD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAC9D;AAEA,QAAI,CAAC,iBAAiB,kBAAkB,YAAY;AAClD,YAAM,IAAI,MAAM,4CAAuC;AAAA,IACzD;AAEA,UAAM,OAA+B,EAAE,KAAK;AAE5C,QAAI,KAAK,SAAS;AAChB,YAAM,WAAW,eAAe,QAAQ,iBAAiB;AACzD,UAAI,CAAC,UAAU;AACb,cAAM,IAAI,MAAM,mEAA8D;AAAA,MAChF;AACA,WAAK,gBAAgB;AAAA,IACvB;AAEA,UAAM,MAAM,MAAM,MAAM,GAAG,KAAK,WAAW,4BAA4B;AAAA,MACrE,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAC9C,MAAM,KAAK,UAAU,IAAI;AAAA,IAC3B,CAAC;AAED,QAAI,CAAC,IAAI,IAAI;AACX,YAAM,MAAM,MAAM,IAAI,KAAK,EAAE,MAAM,OAAO,EAAE,OAAO,wBAAwB,EAAE;AAC7E,YAAM,IAAI,MAAO,IAA2B,SAAS,QAAQ,IAAI,MAAM,EAAE;AAAA,IAC3E;AAEA,mBAAe,WAAW,aAAa;AACvC,mBAAe,WAAW,iBAAiB;AAE3C,WAAO,IAAI,KAAK;AAAA,EAClB;AACF;","names":[]}